<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>SheepHe&#39;s Blog</title>
        <link>https://sheephe66.github.io/</link>
        <description>Recent content on SheepHe&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Sat, 09 Apr 2022 20:35:08 +0800</lastBuildDate><atom:link href="https://sheephe66.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>导入Module</title>
        <link>https://sheephe66.github.io/p/%E5%AF%BC%E5%85%A5module/</link>
        <pubDate>Sat, 09 Apr 2022 20:35:08 +0800</pubDate>
        
        <guid>https://sheephe66.github.io/p/%E5%AF%BC%E5%85%A5module/</guid>
        <description>&lt;img src="https://sheephe66.github.io/3.jpg" alt="Featured image of post 导入Module" /&gt;&lt;h4 id=&#34;解决idea中-module-变成目录无法运行的问题&#34;&gt;解决Idea中 Module 变成目录无法运行的问题&lt;/h4&gt;
&lt;p&gt;在Idea中，有时将项目中的 Module remove 之后，如何将蓝色小方块恢复，使其重新变成Module&lt;/p&gt;
&lt;p&gt;或者将别人的项目导入时，也需要通过这种方法，将其从目录的性转换成Module 来运行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;右击项目根目录，Open Module Settings&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sheephe66.github.io/C:%5cUsers%5chyy000%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20220117172733564.png&#34; alt=&#34;image-20220117172733564&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击Modules，import Module&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sheephe66.github.io/C:%5cUsers%5chyy000%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20220117172807923.png&#34; alt=&#34;image-20220117172807923&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择Maven&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sheephe66.github.io/C:%5cUsers%5chyy000%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20220117172928181.png&#34; alt=&#34;image-20220117172928181&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后点击finish，Apply即可&lt;/strong&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>测试</title>
        <link>https://sheephe66.github.io/p/%E6%B5%8B%E8%AF%95/</link>
        <pubDate>Mon, 22 Nov 2021 19:12:05 +0800</pubDate>
        
        <guid>https://sheephe66.github.io/p/%E6%B5%8B%E8%AF%95/</guid>
        <description>&lt;img src="https://sheephe66.github.io/11.jpg" alt="Featured image of post 测试" /&gt;&lt;p&gt;bbb&lt;/p&gt;
</description>
        </item>
        <item>
        <title>NextCloud搭建私有云</title>
        <link>https://sheephe66.github.io/p/nextcloud%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91/</link>
        <pubDate>Tue, 16 Nov 2021 22:04:39 +0800</pubDate>
        
        <guid>https://sheephe66.github.io/p/nextcloud%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BA%91/</guid>
        <description>&lt;img src="https://sheephe66.github.io/0.jpg" alt="Featured image of post NextCloud搭建私有云" /&gt;&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211116223100.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;其实搭这个网盘也不是说度盘限速个人隐私什么的，主要是因为刚买了个云服务器，就想整点活儿，感觉搭个私人网盘还挺有意思的，用来存点资料还是可以的，但大的文件就不行了，因为买的最基础的ECS n4配置，系统盘最大就只给100G。。真要存东西还得上NAS。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211116223151.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;本篇文章就记录一下搭建网盘的过程，过程中主要使用的是宝塔Linux面板进行站点搭建的，纯Linux命令行应该也可以，但我命令用的还是不熟练，宝塔面板非常方便好用，大大节省了时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sheephe66.github.io/D:%5c%e5%8d%9a%e5%ae%a2img%5cQQ%e6%88%aa%e5%9b%be20211116223921.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;h4 id=&#34;云服务器安装宝塔linux面板&#34;&gt;云服务器安装宝塔Linux面板&lt;/h4&gt;
&lt;p&gt;不同的操作系统对应不同的命令，我的服务器安装的是Ubantu，ssh连接到服务器后，切换到root权限，输入对应命令即可&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CentOS安装命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;yum install -y wget &amp;amp;&amp;amp; wget -O install.sh http://download.bt.cn/install/install_6.0.sh &amp;amp;&amp;amp; sh install.sh
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Ubantu/Deepin安装命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;amp;&amp;amp; sudo bash install.sh
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Debian安装命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh &amp;amp;&amp;amp; bash install.sh
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装完成后，就可以得到&lt;strong&gt;宝塔面板的访问地址&lt;/strong&gt;和&lt;strong&gt;默认管理员账户&lt;/strong&gt;(需要保存下来)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211116225134.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;h4 id=&#34;登录宝塔面板并搭建站点&#34;&gt;登录宝塔面板并搭建站点&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://sheephe66.github.io/D:%5c%e5%8d%9a%e5%ae%a2img%5cQQ%e6%88%aa%e5%9b%be20211111230028.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;直接进外网地址可能无法访问，是因为阿里云后台没有开放端口号，宝塔面板访问地址默认端口号是：8888，需要进阿里云后台配置安全组规则开放8888端口（也可以修改），后面搭建站点也是同理，若没有域名，用ip + 端口号访问的话，用哪一个端口，就要去阿里云安全组放行对应端口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sheephe66.github.io/D:%5c%e5%8d%9a%e5%ae%a2img%5cQQ%e6%88%aa%e5%9b%be20211111225702.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;放行后，登陆成功！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sheephe66.github.io/D:%5c%e5%8d%9a%e5%ae%a2img%5cQQ%e6%88%aa%e5%9b%be20211111234901.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;h4 id=&#34;安装nginxphp等组件&#34;&gt;安装Nginx、php等组件&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://sheephe66.github.io/D:%5c%e5%8d%9a%e5%ae%a2img%5cQQ%e6%88%aa%e5%9b%be20211111231659.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;推荐使用LNMP极速安装（这里不小心踩了个坑，php最好安装最新版本，因为在我弄好之后访问NextCloud时，提示php的版本最低要7.3。。。不过还好可以直接升级）&lt;/p&gt;
&lt;p&gt;接下来就等待安装即可，大概下载了20分钟&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211117153336.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;接下来需要安装两个扩展插件&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211117153343.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;如果有域名的话，可以为域名申请SSL证书，就是用https加密，不会出现不安全的标志。按理说也可以直接给服务器ip直接申请SSL证书，但我点击申请却出错了，不知道为啥。。。不过有没有不影响使用。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211117154052.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;h4 id=&#34;安装nextcloud&#34;&gt;安装NextCloud&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;NextCloud官网下载Linux版的压缩包，宝塔面板上传到服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211117154455.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解压安装到站点目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211117154826.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;OK，接下来就可以直接访问了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211117154942.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;此处就是创建一个管理员账户，登陆进去后，可以在为其他用户分配普通权限账户，还可以分配账户的可用存储容量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211117155216.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JsDelivr加速图床</title>
        <link>https://sheephe66.github.io/p/jsdelivr%E5%8A%A0%E9%80%9F%E5%9B%BE%E5%BA%8A/</link>
        <pubDate>Wed, 10 Nov 2021 13:31:09 +0800</pubDate>
        
        <guid>https://sheephe66.github.io/p/jsdelivr%E5%8A%A0%E9%80%9F%E5%9B%BE%E5%BA%8A/</guid>
        <description>&lt;img src="https://sheephe66.github.io/2.jpg" alt="Featured image of post JsDelivr加速图床" /&gt;&lt;h2 id=&#34;github--jsdelivr--picgo加速图床&#34;&gt;Github + jsDelivr + PicGo加速图床&lt;/h2&gt;
&lt;p&gt;单独使用GitHub做图床，在国内访问时速度加载较慢，记录一下使用免费CDN&lt;/p&gt;
&lt;p&gt;（jsDelivr）给图床加速&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211110140150.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先创建一个GitHub仓库，用于保存博客上传的图片，在设置中获取token&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载安装PicGo，将上面获取的token，填到PicGo配置中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;完成PicGO图床配置，使用jsDelivr就是在PicGo配置最后的自定义域名中填上jsDelivr的加速链接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加速链接：https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gh 表示 Github仓库&lt;/li&gt;
&lt;li&gt;SheepHe66/BlogPictures 表示 仓库名&lt;/li&gt;
&lt;li&gt;main 表示 分支&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211110133335.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最后配合博客使用，就在Typora偏好设置中，选择图像，选择使用PicGo（app）上传图片，并添加PicGo安装路径&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.jsdelivr.net/gh/SheepHe66/BlogPictures@main/img/20211110140209.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;这样，就好了~~&lt;/p&gt;
</description>
        </item>
        <item>
        <title>阿里云服务器安装配置</title>
        <link>https://sheephe66.github.io/p/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</link>
        <pubDate>Tue, 09 Nov 2021 20:17:55 +0800</pubDate>
        
        <guid>https://sheephe66.github.io/p/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</guid>
        <description>&lt;img src="https://sheephe66.github.io/1.jpg" alt="Featured image of post 阿里云服务器安装配置" /&gt;&lt;p&gt;双十一B站UP主给阿里云做活动，买云服务器满58返现60，本来想着白嫖一年的，但又想好好利用新用户的优惠，就买了三年的，170再返现60，相当于110买了三年，感觉很赚。。&lt;/p&gt;
&lt;h4 id=&#34;服务器基本配置&#34;&gt;服务器基本配置&lt;/h4&gt;
&lt;p&gt;阿里云ECS   n4      1核 2G  1M带宽&lt;/p&gt;
&lt;p&gt;操作系统：ubantu 20.04&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SheepHe66/BlogPictures/main/img/20211109211222.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SheepHe66/BlogPictures/main/img/20211109211120.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;h4 id=&#34;安装openjdk18&#34;&gt;安装openjdk1.8&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;更新软件包列表&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get update
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;安装openjdk-8&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install openjdk-8-jdk
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;查看java版本&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;java -version
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SheepHe66/BlogPictures/main/img/20211109214228.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看openjdk装在哪里&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;update-alternatives --config java
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SheepHe66/BlogPictures/main/img/20211109214452.jpg&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Ajax笔记</title>
        <link>https://sheephe66.github.io/p/ajax%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sat, 06 Nov 2021 22:29:21 +0800</pubDate>
        
        <guid>https://sheephe66.github.io/p/ajax%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;img src="https://sheephe66.github.io/6.jpg" alt="Featured image of post Ajax笔记" /&gt;&lt;h3 id=&#34;文章目录&#34;&gt;文章目录&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Ajax概述
1.1 AJAX 简介
1.2 XML 简介
1.3 AJAX 的特点
1.3.1 AJAX 的优点
1.3.2 AJAX 的缺点&lt;/li&gt;
&lt;li&gt;HTTP相关问题
2.1 MDN 文档
2.2 HTTP 请求交互的基本过程
2.3 HTTP 请求报文&lt;/li&gt;
&lt;li&gt;请求行&lt;/li&gt;
&lt;li&gt;多个请求头&lt;/li&gt;
&lt;li&gt;请求体
2.4 HTTP 响应报文
2.5 post 请求体参数格式
2.6 常见的响应状态码
2.7 不同类型的请求及其作用
2.8 API 的分类
2.9 区别 一般http请求 与 ajax请求&lt;/li&gt;
&lt;li&gt;原生AJAX 的基本使用 XHR
3.0 准备工作
3.0.1 安装node.js
3.0.2 安装express（服务端框架）
3.0.3 安装nodemon自动重启工具
3.1 理解
3.2 核心对象使用步骤
3.2.1 创建XMLHttpRequest 对象
3.2.2 设置请求信息（请求方法和url）
3.2.3 发送请求
3.2.4 接收响应（事件绑定，处理服务端返回的结果）
3.3 使用案例
3.3.1 GET 请求&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;get-请求设置请求参数&#34;&gt;GET 请求设置请求参数&lt;/h1&gt;
&lt;p&gt;3.3.2 POST请求&lt;/p&gt;
&lt;h1 id=&#34;设置请求头信息&#34;&gt;设置请求头信息&lt;/h1&gt;
&lt;p&gt;3.4 json数据请求
3.5 请求超时与网络异常
3.6 取消请求
3.7 请求重复发送问题
3.8 解决 IE 缓存问题
3.9 AJAX 请求状态
3.10 API总结&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;jQuery 中的AJAX
4.1 get 请求
4.2 post 请求
4.3 通用方法&lt;/li&gt;
&lt;li&gt;跨域
5.1 同源策略
5.2 如何解决跨域
5.2.1 JSONP
&lt;ol&gt;
&lt;li&gt;JSONP 是什么&lt;/li&gt;
&lt;li&gt;JSONP 怎么工作的？&lt;/li&gt;
&lt;li&gt;JSONP 的使用
1.动态的创建一个script 标签
2.设置script 的src，设置回调函数
3.将script 添加到body 中
4.服务器中路由的处理&lt;/li&gt;
&lt;li&gt;jQuery 中的JSONP
5.2.2 CORS&lt;/li&gt;
&lt;li&gt;CORS 是什么？&lt;/li&gt;
&lt;li&gt;CORS 怎么工作的？&lt;/li&gt;
&lt;li&gt;CORS 的使用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Ajax概述
1.1 AJAX 简介
AJAX 全称为Asynchronous JavaScript And XML，就是异步的JS 和XML
通过AJAX 可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据
AJAX 不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1.2 XML 简介
XML 可扩展标记语言。
XML 被设计用来传输和存储数据。
XML 和HTML 类似，不同的是HTML 中都是预定义标签，而XML 中没有预定义标签，
全都是自定义标签，用来表示一些数据。&lt;/p&gt;
&lt;p&gt;比如说我有一个学生数据：
name = “孙悟空” ; age = 18 ; gender = “男” ;
用XML 表示：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;现在已经被JSON 取代了。&lt;/p&gt;
&lt;p&gt;{&amp;ldquo;name&amp;rdquo;:&amp;ldquo;孙悟空&amp;rdquo;,&amp;ldquo;age&amp;rdquo;:18,&amp;ldquo;gender&amp;rdquo;:&amp;ldquo;男&amp;rdquo;}&lt;/p&gt;
&lt;h4 id=&#34;13-ajax-的特点&#34;&gt;1.3 AJAX 的特点&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.3.1 AJAX 的优点&lt;/strong&gt;
可以无需刷新页面而与服务器端进行通信
允许你根据用户事件来更新部分页面内容
&lt;strong&gt;1.3.2 AJAX 的缺点&lt;/strong&gt;
没有浏览历史，不能回退
存在跨域问题(同源)
SEO 不友好&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;HTTP相关问题
2.1 MDN 文档
&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2.2 HTTP 请求交互的基本过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SheepHe66/BlogPictures/main/img/20211106224542.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;前后应用从浏览器端向服务器发送HTTP 请求(请求报文)
后台服务器接收到请求后, 调度服务器应用处理请求, 向浏览器端返回HTTP响应(响应报文)
浏览器端接收到响应, 解析显示响应体/调用监视回调
2.3 HTTP 请求报文&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;请求行
method url
GET /product_detail?id=2
POST /login&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个请求头
Host: &lt;a href=&#34;http://www.baidu.com&#34;&gt;www.baidu.com&lt;/a&gt;
Cookie: BAIDUID=AD3B0FA706E; BIDUPSID=AD3B0FA706;
Content-Type: application/x-www-form-urlencoded 或者application/json&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求体
username=tom&amp;amp;pwd=123
{&amp;ldquo;username&amp;rdquo;: &amp;ldquo;tom&amp;rdquo;, &amp;ldquo;pwd&amp;rdquo;: 123}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;2.4 HTTP 响应报文
响应状态行: status statusText
多个响应头
Content-Type: text/html;charset=utf-8
Set-Cookie: BD_CK_SAM=1;path=/
响应体
html 文本/json 文本/js/css/图片&amp;hellip;
2.5 post 请求体参数格式
Content-Type: application/x-www-form-urlencoded;charset=utf-8
用于键值对参数，参数的键值用=连接, 参数之间用&amp;amp;连接
例如: name=%E5%B0%8F%E6%98%8E&amp;amp;age=12
Content-Type: application/json;charset=utf-8
用于 json 字符串参数
例如: {&amp;ldquo;name&amp;rdquo;: &amp;ldquo;%E5%B0%8F%E6%98%8E&amp;rdquo;, &amp;ldquo;age&amp;rdquo;: 12}
Content-Type: multipart/form-data
用于文件上传请求
2.6 常见的响应状态码
200 OK 请求成功。一般用于GET 与POST 请求
201 Created 已创建。成功请求并创建了新的资源
401 Unauthorized 未授权/请求要求用户的身份认证
404 Not Found 服务器无法根据客户端的请求找到资源
500 Internal Server Error 服务器内部错误，无法完成请求&lt;/p&gt;
&lt;p&gt;2.7 不同类型的请求及其作用
GET: 从服务器端读取数据（查）
POST: 向服务器端添加新数据 （增）
PUT: 更新服务器端已经数据 （改）
DELETE: 删除服务器端数据 （删）
2.8 API 的分类
REST API: restful （Representational State Transfer (资源)表现层状态转化）
(1) 发送请求进行CRUD 哪个操作由请求方式来决定
(2) 同一个请求路径可以进行多个操作
(3) 请求方式会用到GET/POST/PUT/DELETE
非REST API: restless
(1) 请求方式不决定请求的CRUD 操作
(2) 一个请求路径只对应一个操作
(3) 一般只有GET/POST
2.9 区别 一般http请求 与 ajax请求
ajax请求 是一种特别的 http请求
对服务器端来说, 没有任何区别, 区别在浏览器端
浏览器端发请求: 只有XHR 或fetch 发出的才是ajax 请求, 其它所有的都是非ajax 请求
浏览器端接收到响应
(1) 一般请求: 浏览器一般会直接显示响应体数据, 也就是我们常说的刷新/跳转页面
(2) ajax请求: 浏览器不会对界面进行任何更新操作, 只是调用监视的回调函数并传入响应相关数据&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;原生AJAX 的基本使用 XHR
3.0 准备工作
3.0.1 安装node.js
&lt;a href=&#34;http://nodejs.cn/&#34;&gt;http://nodejs.cn/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3.0.2 安装express（服务端框架）
&lt;a href=&#34;https://www.expressjs.com.cn/&#34;&gt;https://www.expressjs.com.cn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SheepHe66/BlogPictures/main/img/20211106224716.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始化环境&lt;/strong&gt;
npm init &amp;ndash;yes
1
下载express包
npm install express &amp;ndash;save
1
编写js代码
// 1. 引入express
const express = require(&amp;lsquo;express&amp;rsquo;);&lt;/p&gt;
&lt;p&gt;// 2. 创建应用对象
const app = express();&lt;/p&gt;
&lt;p&gt;// 3. 创建路由规则
// request 是对请求报文的封装
// response 是对响应报文的封装
app.get(&#39;/&#39;, (request, response) =&amp;gt; {
//  设置响应
response.send(&amp;ldquo;Hello Express&amp;rdquo;);
});&lt;/p&gt;
&lt;p&gt;// 4. 监听端口，启动服务
app.listen(8000, () =&amp;gt; {
console.log(&amp;ldquo;服务已经启动, 8000 端口监听中&amp;hellip;&amp;quot;);
})&lt;/p&gt;
&lt;p&gt;运行js程序
node .\01express使用.js&lt;/p&gt;
&lt;p&gt;打开网页显示页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SheepHe66/BlogPictures/main/img/20211106224757.gif&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;调试程序可以查看请求和响应&lt;/p&gt;
&lt;p&gt;3.0.3 安装nodemon自动重启工具
文件内容有修改自动重新启动服务
&lt;a href=&#34;https://www.npmjs.com/package/nodemon&#34;&gt;https://www.npmjs.com/package/nodemon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;p&gt;npm install -g nodemon&lt;/p&gt;
&lt;p&gt;启动服务&lt;/p&gt;
&lt;p&gt;ndoemon server.js&lt;/p&gt;
&lt;p&gt;3.1 理解
使用XMLHttpRequest (XHR)对象可以与服务器交互, 也就是发送ajax 请求
前端可以获取到数据，而无需让整个的页面刷新。
这使得Web 页面可以只更新页面的局部，而不影响用户的操作。
&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest&lt;/a&gt;
XMLHttpRequest，AJAX 的所有操作都是通过该对象进行的&lt;/p&gt;
&lt;p&gt;3.2 核心对象使用步骤
3.2.1 创建XMLHttpRequest 对象
var xhr = new XMLHttpRequest();&lt;/p&gt;
&lt;p&gt;3.2.2 设置请求信息（请求方法和url）
// 请求方式
xhr.open(method, url);
//可以设置请求头，一般不设置
xhr.setRequestHeader(&amp;lsquo;Content-Type&amp;rsquo;, &amp;lsquo;application/x-www-form-urlencoded&amp;rsquo;);&lt;/p&gt;
&lt;p&gt;3.2.3 发送请求
xhr.send(body) //get请求不传 body 参数，只有post请求使用&lt;/p&gt;
&lt;p&gt;3.2.4 接收响应（事件绑定，处理服务端返回的结果）
//xhr.responseXML 接收 xml格式 的响应数据
//xhr.responseText 接收 文本格式 的响应数据
xhr.onreadystatechange = function (){
// readyState 是 xhr对象中的属性, 表示状态 0 1 2 3 4
if(xhr.readyState == 4 &amp;amp;&amp;amp; xhr.status == 200){
var text = xhr.responseText;
console.log(text);
}
}&lt;/p&gt;
&lt;h4 id=&#34;33-使用案例&#34;&gt;3.3 使用案例&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;3.3.1 GET 请求&lt;/strong&gt;
点击返回响应信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SheepHe66/BlogPictures/main/img/20211106225056.gif&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;创建两个文件，浏览器端使用的html文件和服务器端使用的js文件&lt;/p&gt;
&lt;p&gt;服务器端 server.js&lt;/p&gt;
&lt;p&gt;// 1. 引入express
const express = require(&amp;lsquo;express&amp;rsquo;);&lt;/p&gt;
&lt;p&gt;// 2. 创建应用对象
const app = express();&lt;/p&gt;
&lt;p&gt;// 3. 创建路由规则
app.get(&#39;/server&#39;, (request, response) =&amp;gt; {
// 设置响应头 设置允许跨域
response.setHeader(&amp;lsquo;Access-Control-Allow-Origin&amp;rsquo;, &amp;lsquo;*&#39;);
// 设置响应体
response.send(&amp;ldquo;Hello Ajax&amp;rdquo;);
});&lt;/p&gt;
&lt;p&gt;// 4. 监听服务
app.listen(8000, () =&amp;gt; {
console.log(&amp;ldquo;服务已经启动, 8000 端口监听中&amp;hellip;&amp;quot;);
})&lt;/p&gt;
&lt;p&gt;启动服务&lt;/p&gt;
&lt;p&gt;node server.js&lt;/p&gt;
&lt;p&gt;前端页面 html&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre&gt;&lt;code&gt;        //设置 result 的文本
        result.innerHTML=xhr.response;
      }else{
      }
    }
  } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;get-请求设置请求参数-1&#34;&gt;GET 请求设置请求参数&lt;/h1&gt;
&lt;p&gt;设置url参数&lt;/p&gt;
&lt;p&gt;xhr.open(&amp;lsquo;GET&amp;rsquo;, &amp;lsquo;http://127.0.0.1:8000/server?a=100&amp;amp;b=200&amp;amp;c=300&amp;rsquo;);&lt;/p&gt;
&lt;p&gt;3.3.2 POST请求
鼠标放到div中，发post请求，将响应体放在div中呈现&lt;/p&gt;
&lt;p&gt;server.js添加post&lt;/p&gt;
&lt;p&gt;app.post(&#39;/server&amp;rsquo;, (request, response) =&amp;gt; {
// 设置响应头, 设置允许跨域
response.setHeader(&amp;lsquo;Access-Control-Allow-Origin&amp;rsquo;, &amp;lsquo;*&#39;);
// 设置响应体
response.send(&amp;ldquo;Hello Ajax POST&amp;rdquo;);
});&lt;/p&gt;
&lt;p&gt;post.html&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h1 id=&#34;设置请求头信息-1&#34;&gt;设置请求头信息&lt;/h1&gt;
&lt;p&gt;// 设置请求体内容的类型
xhr.setRequesHeader(&amp;lsquo;Content-Type&amp;rsquo;,&amp;lsquo;application/x-www-from-urlencoded&amp;rsquo;);
// 自定义头信息
xhr.setRequesHeader(&amp;lsquo;name&amp;rsquo;, &amp;lsquo;ykyk&amp;rsquo;);&lt;/p&gt;
&lt;p&gt;server.js中设置响应头允许自定义请求头 post改成all&lt;/p&gt;
&lt;p&gt;response.setHeader(&amp;lsquo;Access-Control-Allow-Header&amp;rsquo;,&#39;&lt;em&gt;&#39;);
1
3.4 json数据请求
app.all(&#39;/json-server&amp;rsquo;, (request, response) =&amp;gt; {
// 设置响应头, 设置允许跨域
response.setHeader(&amp;lsquo;Access-Control-Allow-Origin&amp;rsquo;, &amp;lsquo;&lt;/em&gt;&#39;);
// 设置响应头, 设置允许自定义头信息
response.setHeader(&amp;lsquo;Access-Control-Allow-Headers&amp;rsquo;, &amp;lsquo;*&#39;);
// 响应一个数据
const data = {
name: &amp;lsquo;atguigu&amp;rsquo;
};
// 对 对象 进行 字符串 转换
let str = JSON.stringify(data)
// 设置响应体
response.send(str);
});&lt;/p&gt;
&lt;p&gt;3.5 请求超时与网络异常
// 超时设置 （2秒）
xhr.timeout = 2000;
// 超时回调
xhr.ontimeout = function(){
alert(&amp;lsquo;网络超时，请稍后重试&amp;rsquo;)
}
// 网络异常回调
xhr.onerror = function(){
alert(&amp;lsquo;网络异常，请稍后重试&amp;rsquo;)
}&lt;/p&gt;
&lt;p&gt;3.6 取消请求
// 手动取消
xhr.abort()&lt;/p&gt;
&lt;p&gt;3.7 请求重复发送问题
3.8 解决 IE 缓存问题
问题：在一些浏览器中(IE),由于缓存机制的存在，ajax 只会发送的第一次请求，剩余多次请求不会在发送给浏览器而是直接加载缓存中的数据。
解决方式：浏览器的缓存是根据url 地址来记录的，所以我们只需要修改url 地址即可避免缓存问题&lt;/p&gt;
&lt;p&gt;xhr.open(&amp;ldquo;get&amp;rdquo;,&amp;quot;/testAJAX?t=&amp;quot;+Date.now());&lt;/p&gt;
&lt;p&gt;3.9 AJAX 请求状态
xhr.readyState 可以用来查看请求当前的状态
&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState&#34;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/SheepHe66/BlogPictures/main/img/20211106225311.png&#34; alt=&#34;&#34;  /&gt;&lt;/p&gt;
&lt;p&gt;0: 表示XMLHttpRequest 实例已经生成，但是open()方法还没有被调用
1: 表示send()方法还没有被调用，仍然可以使用setRequestHeader()，设定HTTP请求的头信息
2: 表示send()方法已经执行，并且头信息和状态码已经收到
3: 表示正在接收服务器传来的body 部分的数据
4: 表示服务器数据已经完全接收，或者本次接收已经失败了
3.10 API总结
XMLHttpRequest()：创建 XHR 对象的构造函数
status：响应状态码值，如 200、404
statusText：响应状态文本，如 ’ok‘、‘not found’
readyState：标识请求状态的只读属性 0-1-2-3-4
onreadystatechange：绑定 readyState 改变的监听
responseType：指定响应数据类型，如果是 ‘json’，得到响应后自动解析响应
response：响应体数据，类型取决于 responseType 的指定
timeout：指定请求超时时间，默认为 0 代表没有限制
ontimeout：绑定超时的监听
onerror：绑定请求网络错误的监听
open()：初始化一个请求，参数为：(method, url[, async])
send(data)：发送请求
abort()：中断请求 （发出到返回之间）
getResponseHeader(name)：获取指定名称的响应头值
getAllResponseHeaders()：获取所有响应头组成的字符串
setRequestHeader(name, value)：设置请求头&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;jQuery 中的AJAX
4.1 get 请求
$.get(url, [data], [callback], [type])
1
url:请求的URL 地址
data:请求携带的参数
callback:载入成功时回调函数
type:设置返回内容格式，xml, html, script, json, text, _default
4.2 post 请求
$.post(url, [data], [callback], [type])
1
url:请求的URL 地址
data:请求携带的参数
callback:载入成功时回调函数
type:设置返回内容格式，xml, html, script, json, text, _default
4.3 通用方法
$.ajax({
// url
url: &amp;lsquo;http://127.0.0.1:8000/jquery-server&amp;rsquo;,
// 参数
data: {a:100, b:200},
// 请求类型
type: &amp;lsquo;GET&amp;rsquo;,
// 响应体结果
dataType: &amp;lsquo;json&amp;rsquo;,
// 成功的回调
success: function(data){console.log(data);},
// 超时时间
timeout: 2000,
// 失败的回调
error: function(){console.log(&amp;lsquo;出错拉~&#39;);},
// 头信息
headers: {
c: 300,
d: 400
}
})&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跨域
5.1 同源策略
同源策略(Same-Origin Policy)最早由Netscape 公司提出，是浏览器的一种安全策略
同源： 协议、域名、端口号必须完全相同
跨域： 违背同源策略就是跨域
5.2 如何解决跨域
5.2.1 JSONP&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JSONP 是什么
JSONP(JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明
才智开发出来，只支持get 请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;JSONP 怎么工作的？
在网页有一些标签天生具有跨域能力，比如：img link iframe script。
JSONP 就是利用script 标签的跨域能力来发送请求的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JSONP 的使用
1.动态的创建一个script 标签
var script = document.createElement(&amp;ldquo;script&amp;rdquo;);
1
2.设置script 的src，设置回调函数
script.src = &amp;ldquo;http://localhost:3000/testAJAX?callback=abc&amp;rdquo;;
function abc(data) {
alert(data.name);
};&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3.将script 添加到body 中
document.body.appendChild(script);&lt;/p&gt;
&lt;p&gt;4.服务器中路由的处理
router.get(&amp;quot;/testAJAX&amp;rdquo; , function (req , res) {
console.log(&amp;ldquo;收到请求&amp;rdquo;);
var callback = req.query.callback;
var obj = {
name:&amp;ldquo;孙悟空&amp;rdquo;,
age:18
}
res.send(callback+&amp;quot;(&amp;quot;+JSON.stringify(obj)+&amp;quot;)&amp;quot;);
});&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;jQuery 中的JSONP&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;CORS 是什么？
CORS（Cross-Origin Resource Sharing），跨域资源共享。CORS 是官方的跨域解决方
案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持
get 和post 请求。跨域资源共享标准新增了一组HTTP 首部字段，允许服务器声明哪些
源站通过浏览器有权限访问哪些资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CORS 怎么工作的？
CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应
以后就会对响应放行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CORS 的使用
主要是服务器端的设置：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;router.get(&amp;quot;/testAJAX&amp;rdquo; , function (req , res) {
//通过res 来设置响应头，来允许跨域请求
//res.set(&amp;ldquo;Access-Control-Allow-Origin&amp;rdquo;,&amp;ldquo;http://127.0.0.1:3000&amp;rdquo;);
res.set(&amp;ldquo;Access-Control-Allow-Origin&amp;rdquo;,&amp;quot;*&amp;quot;);
res.send(&amp;ldquo;testAJAX 返回的响应&amp;rdquo;);
});&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JavaSE 面向对象</title>
        <link>https://sheephe66.github.io/p/javase-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
        <pubDate>Tue, 18 May 2021 19:21:07 +0800</pubDate>
        
        <guid>https://sheephe66.github.io/p/javase-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
        <description>&lt;img src="https://sheephe66.github.io/5.jpg" alt="Featured image of post JavaSE 面向对象" /&gt;&lt;h4 id=&#34;javase--面向对象整合&#34;&gt;JavaSE&amp;ndash;面向对象整合&lt;/h4&gt;
&lt;h4 id=&#34;面向对象的三条主线&#34;&gt;面向对象的三条主线&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类和类员：属性，方法，构造器，代码块等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向对象的三大特征：封装，继承，多态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他关键字:this,super,abstract,interface,static,
final,package,import&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;封装&#34;&gt;封装&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;封装性的体现：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们将类的属性xxx私有化（private），同时，提供公共的（public）方法来获取（getxxx）和设置（setxxx）此属性的值&lt;/li&gt;
&lt;li&gt;不对外暴露的私有方法&lt;/li&gt;
&lt;li&gt;单例模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;权限修饰符权限从小到大&#34;&gt;权限修饰符：(权限从小到大)&lt;/h5&gt;
&lt;p&gt;private   ,     缺省（不写） ,    protected   ,    public&lt;/p&gt;
&lt;h4 id=&#34;继承&#34;&gt;继承&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;一旦子类A继承了父类B，则子类A就获得了父类B中声明的结构（所有属性、方法等，包括封装性）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java继承的规定&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;单继承性：一个类只能有一个父类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子父类是相对的概念&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子类直接继承的父类，称为：直接父类。间接继承的父类称为间接父类（java中一个子类不存在多个父类，只有间接继承，即一个子类的父类是另一个类的子类）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;多态&#34;&gt;多态&lt;/h4&gt;
&lt;p&gt;可以理解为一个事物的多种形态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也称为对象的多态性：父类的引用指向子类的对象。 eg：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Man&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Women&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//对象的多态性，父类的引用指向子类的对象
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Man&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Women&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;多态性的使用虚拟方法调用&#34;&gt;多态性的使用：虚拟方法调用&lt;/h5&gt;
&lt;p&gt;有了多态性以后，在编译的时候，只能调用父类的声明的方法，而运行时，实际执行的是&lt;strong&gt;子类重写父类的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即：&lt;strong&gt;编译看左边，运行看右边&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;多态性的使用前提：①有类的继承；②有方法的重写&lt;/p&gt;
&lt;p&gt;多态性属于&lt;strong&gt;运行时行为&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;​							多态小结
多态作用： 提高了代码的通用性，常称作接口重用
前提：需要存在继承或者实现关系, 有方法的重写
成员方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编译时：要查看引用变量所声明的类中是否有所调用的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行时：调用实际new的对象所属的类中的重写方法。&lt;/p&gt;
&lt;p&gt;成员变量：不具备多态性，只看引用变量所声明的类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;如果没有多态性，则需要写很多重载的方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多态性只使用于方法，不适用于属性&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;构造器&#34;&gt;构造器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;每一个类都有构造器&lt;/li&gt;
&lt;li&gt;构造器的作用：&lt;strong&gt;①创建对象；②给对象初始化（属性）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器&lt;/p&gt;
&lt;p&gt;2，定义构造器的格式：&lt;strong&gt;权限修饰符   类名（形参列表）{}&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
    
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;3，一个类中可以有多个构造器，彼此构成重载&lt;/p&gt;
&lt;p&gt;4，没有显式定义的才会有默认构造器，一旦显式的定义了构造器，系统则                不再提供空参构造器&lt;/p&gt;
&lt;p&gt;5，一个类至少有一个构造器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6，默认构造器的权限和所在类的权限相同&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;属性赋值顺序&#34;&gt;属性赋值顺序：&lt;/h5&gt;
&lt;p&gt;①默认初始化&lt;/p&gt;
&lt;p&gt;②显式初始化&lt;/p&gt;
&lt;p&gt;③构造器中赋值&lt;/p&gt;
&lt;p&gt;④通过“对象  .  属性”或“对象  .  方法”赋值&lt;/p&gt;
&lt;h4 id=&#34;this关键字&#34;&gt;this关键字&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;this相当于：&lt;strong&gt;当前对象或当前正在创建的对象&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用来区分重名的属性和形参&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用来修饰：&lt;strong&gt;属性，方法，构造器&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;this 调用构造器：（根据参数列表调用）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;//调用空参的构造器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;形参列表&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;规定：调用构造器时，“this（形参列表）”必须声明在当前构造器的首行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构造器中不能用this调用自己，只能调其他的构造器&lt;/p&gt;
&lt;p&gt;如果一个类中有n个构造器，则最多只能有n-1个this调用构造器，不能往回调&lt;/p&gt;
&lt;h4 id=&#34;super关键字&#34;&gt;super关键字&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;super理解为：父类的（类似this用法）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;super可以调用 属性、方法、构造器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以在子类的方法或构造器中，通过 super . 属性 或 super . 方法的方式，显式的调用父类中声明的属性或方法。通常情况下，习惯省略super&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特殊的，子类和父类定义了同名的属性时，此时若要调用父类的属性，必须使用super调用父类的&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;父类方法被重写后，需要使用super调用父类中的被重写的方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;super调用父类构造器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;形参列表&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;super（形参列表）必须声明在构造器的首行&lt;/li&gt;
&lt;li&gt;this（形参列表）和super（形参列表）不能同时出现&lt;/li&gt;
&lt;li&gt;默认调用super（空）&lt;/li&gt;
&lt;li&gt;在类的多个构造器中，至少有一个类的构造器是用来super（形参列表）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;方法详解&#34;&gt;方法详解&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;方法的重载&lt;/li&gt;
&lt;li&gt;可变形参的方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法参数的值传递机制&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;递归方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;方法重载&#34;&gt;方法重载：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;与返回值无关，只看参数列表且参数列表必须不同（参数个数或参数类型）&lt;/p&gt;
&lt;p&gt;调用时，根据方法参数列表的不同来区别&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下方法都是重载：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getsum&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getsum&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getsum&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getsum&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;即使是参数列表顺序不同，也构成重载，根据传递参数顺序调用具体的函数&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;跟方法的权限修饰符，返回值类型，形参变量名，方法体都无关&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通过对象调用方法时，如何确定某一指定方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看方法名，如果有重载，再根据参数列表判断（方法名&amp;mdash;&amp;mdash;&amp;gt;参数列表）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;可变个数的形参&#34;&gt;可变个数的形参：&lt;/h5&gt;
&lt;p&gt;1.JDK5.0新增内容,调用可变个数形参时，可以传入多个参数&lt;/p&gt;
&lt;p&gt;2.具体使用：&lt;/p&gt;
&lt;p&gt;​       格式：变量类型&amp;hellip;形参变量名，eg：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//调用时可以同时传递多个参数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;test&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;world&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;he&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;JDK5.0以前需要传递多个参数时，使用的是数组，因此可变形参新特性不能续数组共存（会构成重载）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//以下方法构成重载（表示的是同一个东西）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
    
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;arr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
    
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;方法的形参传递机制值传递&#34;&gt;方法的形参传递机制：值传递&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;机制：如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;swap(a,b);&lt;/p&gt;
&lt;p&gt;只有参数类类型为引用数据类型（类的对象）时才能交换，eg：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;punlic&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;swap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;swap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Data&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;temp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;temp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关于变量赋值：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果变量是基本数据类型，此时传递的是保存数据的值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果变量是引用数据类型，此时传递的是保存数据的地址&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;递归方法&#34;&gt;递归方法&lt;/h5&gt;
&lt;p&gt;方法内调用方法本身，例如，斐波那契数列，汉诺塔问题&lt;/p&gt;
&lt;h4 id=&#34;方法的重写&#34;&gt;方法的重写&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;override  /  overwrite&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;重写：子类继承父类以后，可以对父类中同名同参数的方法进行覆盖操作（适当改变方法体的内容）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用：重写以后，当创建类对象以后，通过&lt;strong&gt;子类对象&lt;/strong&gt;调用父类中的同名同参数的方法时，实际执行的是子类重写父类的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重写的规定：&lt;/p&gt;
&lt;p&gt;​	方法的声明：&lt;strong&gt;权限修饰符	返回值类型	方法名（形参列表）{&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​									&lt;strong&gt;//方法体（不同）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​						&lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法&lt;/p&gt;
&lt;p&gt;①两个方法的方法名和形参列表必须相同，方法体不同&lt;/p&gt;
&lt;p&gt;②子类中的重写的方法权限修饰符不小于父类中的被重写的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tips：子类不能重写父类中的声明为private权限的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;③返回值类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父类中被重写的方法是返回值类型是void类型，则子类中返回值只能是void 类型&lt;/li&gt;
&lt;li&gt;父类中被重写的方法是返回值类型是A类型，则子类中可以是A类型或A类型的子类&lt;/li&gt;
&lt;li&gt;父类中被重写的方法是返回值类型是基本数据类型，则子类中必须是相同的基本数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;tostring的使用&#34;&gt;toString()的使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;输出一个对象的引用时，实际上就是调用当前对象的toString()方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;调用父类的构造器：super.toString&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;？如何实现调用父类的父类的toString方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将根父类（父类的父类）中重写的toString方法体放在一个新的方法中,例如：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@override
public String getToString(){
    return id + name + age + salary;
}
public String toString(){
    return getToString;//return id + name + age + salary;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;接着在子类的子类中调用 ：getToString()方法&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;instanceof关键字&#34;&gt;instanceof关键字&lt;/h4&gt;
&lt;h5 id=&#34;instanceof关键字的使用&#34;&gt;instanceof关键字的使用&lt;/h5&gt;
&lt;h5 id=&#34;多态性的弊端&#34;&gt;多态性的弊端&lt;/h5&gt;
&lt;p&gt;有了多态性以后，内存中实际上是加载了子类所特有的属性和方法，但由于变量声明为父类类型(eg：Person p1 = new Man(); ),所以导致编译时，&lt;strong&gt;p1对象只能调用父类中声明的属性和方法（包括子类重写的），而不能调用子类所特有的属性和方法&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;向下转型&#34;&gt;向下转型&lt;/h5&gt;
&lt;p&gt;目的就是：&lt;strong&gt;调用子类特有的属性和方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向下转型：使用强制类型转换符&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Man&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Man&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Man&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//将声明为Person类型的对象强转为Man类型
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;将子类赋给父类&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;向上转型&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;多态&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;是自动类型提升&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;而将父类赋给子类则需要强转&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为了避免向下转型时出现异常&lt;/strong&gt;，转型前使用instanceof关键字进行判断，若返回true，继续；返回false，不继续向下转型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;a instanceof A  :判断对象a是否是类A的实例，如果是，返回true；如果不是，返回false&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 a instanceof A返回true，a instanceof B 也返回true，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中B是A的父类&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;static关键字&#34;&gt;static关键字&lt;/h4&gt;
&lt;p&gt;有些属性是每个对象都共同拥有，不用给每个对象都定义，static针对的是类，不针对具体的对象，每个对象都公共的拥有同一个static变量&lt;/p&gt;
&lt;h5 id=&#34;static关键字的使用&#34;&gt;static关键字的使用&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;static：静态的&lt;/li&gt;
&lt;li&gt;static可以修饰&lt;strong&gt;属性、方法、代码块、内部类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h5 id=&#34;static修饰属性&#34;&gt;static修饰属性&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;static修饰的属性称为&lt;strong&gt;静态变量( 或类变量)&lt;/strong&gt;，非static修饰的属性称为&lt;strong&gt;实例变量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以通过类直接调用静态属性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;静态属性随着类的加载而加载&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;实例变量&lt;/strong&gt;：我们创建了多个对象，每个对象都独立的拥有一套非静态属性。当通过其中一个对象修改非静态属性时，&lt;strong&gt;其他对象的此属性不会被影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态变量&lt;/strong&gt;：我们创建了多个对象，这多个对象共同享有同一个静态变量。&lt;strong&gt;通过一个对象修改静态属性时，由于静态属性时公共的，因此其他对象再调用此静态变量时，是被修改过的&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;栈：局部变量&lt;/p&gt;
&lt;p&gt;堆：new出来的结构：对象、数组&lt;/p&gt;
&lt;p&gt;方法区：类的加载信息、静态域、常量池&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;static修饰方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态方法中不能调用非静态的属性或方法(因为非静态的生命周期不够，静态方法加载完成时还没有非静态的)&lt;/li&gt;
&lt;li&gt;在静态的方法内，不能使用this、super关键字（this、super都基于当前对象）&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;属性：开发中，当属性可以被多个对象共享，不会随着对象的改变而改变时，可以定义为static&lt;/li&gt;
&lt;li&gt;方法：工具类中的方法，习惯声明为static&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading&#34;&gt;&lt;/h4&gt;
&lt;h3 id=&#34;包装类wrapper&#34;&gt;包装类(Wrapper)&lt;/h3&gt;
&lt;h4 id=&#34;包装类介绍&#34;&gt;包装类介绍&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;希望让八种基本数据类型具有类的特征&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;针对八种基本数据类型定义相应的引用类型&amp;mdash;&amp;ndash;包装类(封装类)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;基本数据类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;包装类&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;byte&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Byte&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;short&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;Integer&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;long&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;double&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;boolean&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;strong&gt;Character&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h4 id=&#34;基本数据类型包装类之间的转换&#34;&gt;基本数据类型、包装类之间的转换&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//基本数据类型---&amp;gt;包装类:调用包装类的构造器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;//包装类---&amp;gt;基本数据类型:调用xxx包装类的xxxValue()
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;intValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;Float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Float&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;floatValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;jdk-50新特性自动装箱与自动拆箱&#34;&gt;JDK 5.0新特性：自动装箱与自动拆箱&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;自动装箱：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//自动实现基本数据类型---&amp;gt;包装类(不用调用构造器)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//自动装箱
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;自动拆箱：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//自动实现包装类---&amp;gt;基本数据类型(不用调用xxx.Value())
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//自动拆箱
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;string类与基本数据类型包装类之间的转换&#34;&gt;String类与基本数据类型、包装类之间的转换&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//String类型---&amp;gt;基本数据类型、包装类:调用包装类型的               parsexxx(String str)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;123&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;parseInt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;//125
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//基本数据类型、包装类---&amp;gt;String类型:调用String重载的             ValueOf(Xxx xxx)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;valueOf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;	 &lt;span class=&#34;c1&#34;&gt;//10.12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;抽象类与抽象方法&#34;&gt;抽象类与抽象方法&lt;/h3&gt;
&lt;h4 id=&#34;abstract&#34;&gt;abstract&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;抽象的，不实例&lt;/li&gt;
&lt;li&gt;可以修饰：类、方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;抽象类&#34;&gt;抽象类：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;此类不能实例化，即不能造此类的对象&lt;/li&gt;
&lt;li&gt;但一定有构造器，因为此类的子类继承后，还需要调用此父类的构造器&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;抽象方法&#34;&gt;抽象方法：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;没有方法体，没有大括号，只有方法的声明&lt;/li&gt;
&lt;li&gt;由于没有方法体，所以不能用对象调用，因此&lt;strong&gt;包含抽象方法的类一定是抽象类&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若子类重写了父类的&lt;strong&gt;所有抽象方法&lt;/strong&gt;后，才能实例化；若子类没有重写父类的抽象的方法，则子类必须是抽象类&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;abstract使用注意点&#34;&gt;abstract使用注意点：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;不能用来修饰属性、构造器、代码块等结构&lt;/li&gt;
&lt;li&gt;不能用来修饰私有方法（子类必须重写抽象父类的方法，但private不能被重写&lt;/li&gt;
&lt;li&gt;不能用来修饰静态方法、final方法、final类&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;抽象类的匿名子类&#34;&gt;抽象类的匿名子类：&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//子类的重写的方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nd&#34;&gt;@override&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;单例设计模式&#34;&gt;单例设计模式&lt;/h4&gt;
&lt;p&gt;让一个类只能存在一个对象实例，并且该类只提供一个获得其对象实例的方法，如果我们要让类在虚拟机中只能产生一个对象，首先要将类的构造器访问权限设置为&lt;strong&gt;private&lt;/strong&gt;,这样就不能用new操作符在类的外部产生类的对象了。由于在类的外部无法得到类的对象，只能调用该类的静态get方法以返回类内部创建的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单例设计模式主要分四步：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.将类的构造器设置为私有&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.类内部创建类的对象（私有、静态）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.提供共有的静态方法从类外获取类的对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.步骤二中对象也必须声明为静态的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单例设计模式主要有：&lt;strong&gt;饿汉式&lt;/strong&gt; 和 &lt;strong&gt;懒汉式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;饿汉式：提前创建好对象，安全但占用多余空间&lt;/p&gt;
&lt;p&gt;懒汉式：对象在需要用的时候再创建，节省空间但不够安全&lt;/p&gt;
&lt;h3 id=&#34;异常&#34;&gt;异常&lt;/h3&gt;
&lt;p&gt;java.lang.Throwable:&lt;/p&gt;
&lt;p&gt;​		&amp;gt;java.lang.Error:一般不编写针对代码处理&lt;/p&gt;
&lt;p&gt;​		&amp;gt;java.lang.Exception:异常一般指这个，可以进行异常的处理&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Exception分为：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;编译时异常（checked）：&lt;/p&gt;
&lt;p&gt;IOException —&amp;gt;FileNotFoundException&lt;/p&gt;
&lt;p&gt;ClassNotFoundException&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行时异常（unchecked, RuntimeException）:&lt;/p&gt;
&lt;p&gt;NullPointerException&lt;/p&gt;
&lt;p&gt;ArrayIntexOutOfBoundsException&lt;/p&gt;
&lt;p&gt;ClassCastException&lt;/p&gt;
&lt;p&gt;NumberFormatException&lt;/p&gt;
&lt;p&gt;InputMismatchException&lt;/p&gt;
&lt;p&gt;ArithmetiException&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;异常处理&#34;&gt;异常处理&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;抓抛模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;过程一&amp;quot;抛&amp;quot;：程序在正常执行的过程中，一旦出现异常，就会在异常处生成一个异常类的对象，并将此对象抛出。&lt;/p&gt;
&lt;p&gt;一旦抛出对象以后，其后的代码不再执行&lt;/p&gt;
&lt;p&gt;过程二：&amp;ldquo;抓&amp;rdquo;：可以理解为异常的处理方式：&lt;/p&gt;
&lt;p&gt;​		①try—catch—finally&lt;/p&gt;
&lt;p&gt;​		②throws&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//try-catch-finally的使用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; 
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; 		&lt;span class=&#34;c1&#34;&gt;//可能出现异常的代码
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; 
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;异常类型1&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;变量名1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; 		&lt;span class=&#34;c1&#34;&gt;//处理异常的方式1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;异常类型2&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;变量名2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; 		&lt;span class=&#34;c1&#34;&gt;//处理异常的方式2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;异常类型3&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;变量名3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; 		&lt;span class=&#34;c1&#34;&gt;//处理异常的方式3
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;....&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;finally&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
 &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; 		&lt;span class=&#34;c1&#34;&gt;//一定会执行的代码
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;异常处理方式二： throws  +   异常类型&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;throws  +  异常类型&amp;rdquo; 写在方法的声明处。指明此方法执行时，可能会抛出的异常类型&lt;/p&gt;
&lt;p&gt;一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类常时，就会被抛出。异常代码后续的代码不再执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;体会：try—catch—finally：&lt;strong&gt;真正地将异常处理了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​			throws：只是将异常抛给了方法的调用者，并没有处理&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;子类重写方法异常的规则&#34;&gt;子类重写方法异常的规则：&lt;/h4&gt;
&lt;p&gt;子类重写的方法中throws的异常类型&lt;strong&gt;只能小于等于&lt;/strong&gt;父类中的异常类型，子类中也可以没有&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;开发中如何选择trycatchfinally---or---throws-&#34;&gt;开发中如何选择？（try—catch—finally   or   throws ）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如果父类中被重写的方法没有throws方式处理异常，则子类中也不能用throws，此时如果子类中如果有异常，必须使用try-catch-finally处理。&lt;/li&gt;
&lt;li&gt;执行的方法A中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。建议让这几个方法使用throws处理，而执行的方法A可以考虑使用try-catch-finally处理&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;手动抛出异常&#34;&gt;手动抛出异常&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;throw new 异常对象名();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;异常对象需要继承于异常体系，一般写 Exception 或 RuntimeException&lt;/p&gt;
&lt;p&gt;也可以自定义，但必须继承于异常体系&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>第一篇正经博客！</title>
        <link>https://sheephe66.github.io/p/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%AD%A3%E7%BB%8F%E5%8D%9A%E5%AE%A2/</link>
        <pubDate>Fri, 23 Apr 2021 22:03:34 +0800</pubDate>
        
        <guid>https://sheephe66.github.io/p/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%AD%A3%E7%BB%8F%E5%8D%9A%E5%AE%A2/</guid>
        <description>&lt;img src="https://sheephe66.github.io/7.jpg" alt="Featured image of post 第一篇正经博客！" /&gt;&lt;p&gt;我的博客终于搭建成功了，真是不容易啊！！！今天来写篇正经博客！&lt;/p&gt;
&lt;p&gt;目前博客只有两篇文章，不过都是用来测试的。。。第一篇FirstBlog是博客首次本地启动的时候随便写的用来测试本地有没有启动成功的，第二篇计算机网络脉络梳理，  作为第二次测试记得好像是已经搭建好了，也部署到Github上去了，然后测试更新文章来着。emmm······看起来是很干货，其实是从B站UP主CodeSheep(一个宝藏程序猿UP)的的一期干货视频里做的笔记，主要是针对面试的计算机网络学习路线梳理。因为这个已经是总结好的了，反正以后也是要发的，就干脆作为测试发布了。&lt;/p&gt;
&lt;p&gt;第一篇(正经)博客，不知道写啥，那还是来聊聊我的博客是怎么搭建的吧，毕竟搭博客的过程中踩了太多坑了。。。我还截了好多图，必须记录一下！&lt;/p&gt;
&lt;p&gt;我其实很早就想弄一个自己的个人博客网站了，作为一个非计算机专业的我觉得这很酷。大概去年吧，还真的去尝试了一下，很显然，以失败告终。。。当时是在知乎上找的教程，那上面让去Github上面clone别人的博客框架，看着教程简单，但第一步就出错了，一个按钮直接变成灰色不让我点。。。WTF！然后就没有然后了。但前一段时间在B站关注了一个宝藏程序猿UP，就是上面提到的CodeSheep，我羊哥！视频、微信公众号全是干货，好家伙，简直我的最爱呀！翻到以前的视频，好几期都是关于小白如何搭建自己的个人博客的，还说博客对以后的面试会很有帮助，一下子就让我重新燃起了自信！于是选了一个简单点Hugo博客框架，但由于他是MAC OS，我又去CSDN找了一个详细的教程，就开始了。&lt;/p&gt;
&lt;p&gt;还是那句话，教程看着简单，一步一步的很详细，但总是会在莫名其妙的位置出各种莫名其妙的错误！&lt;strong&gt;前面瞎BB了半天，这里来写一下具体步骤以及踩坑是怎么处理的吧。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;windows系统上基于hugo博客框架创建个人博客&#34;&gt;Windows系统上基于Hugo博客框架创建个人博客&lt;/h4&gt;
&lt;p&gt;下载Hugo博客框架，配置环境变量，检查是否安装成功&lt;/p&gt;
&lt;p&gt;下载Git并安装&lt;/p&gt;
&lt;p&gt;创建一个博客文件夹Blog，里面再放一个BlogOne文件夹，在&lt;strong&gt;当前目录下右键&lt;/strong&gt;打开Git，输入：hugo new site SheepHe(博客名)&lt;/p&gt;
&lt;p&gt;打开SheepHe，下载hugo博客主题（https://themes.gohugo.io/）&lt;/p&gt;
&lt;p&gt;复制主题链接后，在themes目录下输入：git clone +主题地址&lt;/p&gt;
&lt;p&gt;（需要将exampleSite文件夹里的config文件复制并替换根目录下的config文件)&lt;/p&gt;
&lt;p&gt;本地启动博客，hugo server -t hugo-theme-stack &amp;ndash;buildDrafts&lt;/p&gt;
&lt;p&gt;此时复制http://localhost:1313到浏览器可以本地访问&lt;/p&gt;
&lt;p&gt;写文章，根目录下，hugo new post/文章名.md,然后打开Typora等编辑器写文章，接着重新运行，hugo server -t hugo-theme-stack &amp;ndash;buildDrafts&lt;/p&gt;
&lt;p&gt;接着部署到Github上，&lt;strong&gt;重点就在这儿&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;新建Github项目&lt;/p&gt;
&lt;p&gt;根目录下，输入：&lt;/p&gt;
&lt;p&gt;hugo &amp;ndash;theme=hugo-theme-stack &amp;ndash;baseUrl=&amp;ldquo;&lt;a href=&#34;https://sheephe66.github.io/%22&#34;&gt;https://sheephe66.github.io/&amp;quot;&lt;/a&gt; &amp;ndash;buildDrafts&lt;/p&gt;
&lt;p&gt;会生成一个public文件夹，标准步骤是：在此public文件夹下输入：&lt;/p&gt;
&lt;p&gt;git init
git add .
git commit -m &amp;ldquo;我的博客第一次提交&amp;rdquo;
git remote add origin &lt;a href=&#34;https://github.com/sheephe66/sheephe66.github.io.git&#34;&gt;https://github.com/sheephe66/sheephe66.github.io.git&lt;/a&gt;
git push -u -origin master&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就是要push这个public文件夹，是不是看着很简单，我以为我都要成功了，最后一步push，Git报了一个致命错误，我看不懂!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后来请教好多人，以及百度谷歌了好久还是没能解决，最后请教了B站另一位良心UP主 ，我水哥，一个架构师，他让他小弟帮我解决的，不过还是没能解决那个报错，用的另外一种方法，&lt;strong&gt;将Github仓库clone到本地，然后将public文件夹复制到仓库里&lt;/strong&gt;，然后整个一起提交，终于解决了！当时激动了好久！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ps:水哥说，这种方法还适用于以后工作，不行就把项目拉到本地，直接clone，很有效！嗯嗯，学到了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OK，就BB这么多了，以后就不说这么多废话了，尽量更新一些阶段性学习成果、笔记和心得！学习去了~~~&lt;/p&gt;
</description>
        </item>
        <item>
        <title>计算机网络脉络梳理</title>
        <link>https://sheephe66.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%84%89%E7%BB%9C%E6%A2%B3%E7%90%86/</link>
        <pubDate>Mon, 19 Apr 2021 17:37:55 +0800</pubDate>
        
        <guid>https://sheephe66.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%84%89%E7%BB%9C%E6%A2%B3%E7%90%86/</guid>
        <description>&lt;img src="https://sheephe66.github.io/4.jpg" alt="Featured image of post 计算机网络脉络梳理" /&gt;&lt;h3 id=&#34;计算机网络脉络梳理&#34;&gt;计算机网络脉络梳理&lt;/h3&gt;
&lt;p&gt;主要指&lt;strong&gt;TCP/IP 协议栈&lt;/strong&gt;，大部分隐藏于操作系统内核（数据链路层，网络层，传输层），封装于操作系统内部，但是要&lt;strong&gt;了解原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据链路层&lt;/p&gt;
&lt;p&gt;网络层：IP&lt;/p&gt;
&lt;p&gt;传输层：TCP，UDP&lt;/p&gt;
&lt;p&gt;平时用户空间接触到只有应用层协议：&lt;strong&gt;FTP，HTTP，DNS，HTTPS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作中接触的以应用层为主&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&#34;数据链路层&#34;&gt;数据链路层&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;以太网帧的格式&lt;/li&gt;
&lt;li&gt;MTU的概念&lt;/li&gt;
&lt;li&gt;ARP协议 和RARP协议（ARP报文格式，ARP缓存原理）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;网络层&#34;&gt;网络层&lt;/h4&gt;
&lt;h5 id=&#34;ip协议&#34;&gt;IP协议：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;掌握IP首部标识：如16位分片标识、DF不分片标志、MF更多分片标志、13位片位移，8位生存空间TTL，16位的首部检验等等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;掌握IP分片：避免IP分片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路由表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;掌握ICMP协议：报文格式、报文的两大分类：查询+差错&lt;/p&gt;
&lt;p&gt;​							 2钟报文格式 + 5钟差错控&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;传输层&#34;&gt;传输层&lt;/h4&gt;
&lt;h5 id=&#34;udp协议&#34;&gt;UDP协议：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;特点 + 首部各个字段&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;tcp协议&#34;&gt;TCP协议：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;特点 + 首部各个字段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP连接控制：&lt;strong&gt;三次握手、四次挥手、同时打开、同时关闭、半关闭&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP流量控制机制：&lt;strong&gt;滑动窗口、慢启动、拥塞避免、快速重传、快速恢复&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP超时重传机制：各种定时器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;（学的过程中多问为什么？比如为什么是三次握手、四次挥手）&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;应用层&#34;&gt;应用层&lt;/h4&gt;
&lt;h5 id=&#34;dns协议&#34;&gt;DNS协议：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;DNS协议的名字空间、DNS指针查询(反向查找或逆向解析)基本原理、DNS缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;ftp协议&#34;&gt;FTP协议：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;两条连接：控制连接 + 数据连接&lt;/li&gt;
&lt;li&gt;两种工作模式：PASV + PORT&lt;/li&gt;
&lt;li&gt;各种FTP的指令 和 响应码&lt;/li&gt;
&lt;li&gt;FTP断点续传、匿名FTP&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;http协议&#34;&gt;HTTP协议：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;报文格式：请求报文、响应报文、请求头各种字段、响应头各种字段&lt;/li&gt;
&lt;li&gt;http状态码&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;https协议&#34;&gt;HTTPS协议：&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;https协议的详细握手过程&lt;/li&gt;
&lt;li&gt;摘要算法、数字签名、数字证书的原理和过程&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>FirstBlog</title>
        <link>https://sheephe66.github.io/p/firstblog/</link>
        <pubDate>Sat, 17 Apr 2021 11:24:46 +0800</pubDate>
        
        <guid>https://sheephe66.github.io/p/firstblog/</guid>
        <description>&lt;p&gt;2020.04.17  11:26  ，我的博客第三次搭建。。。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
